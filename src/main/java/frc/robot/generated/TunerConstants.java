package frc.robot.generated;

import static edu.wpi.first.units.Units.*;

import com.ctre.phoenix6.CANBus;
import com.ctre.phoenix6.configs.*;
import com.ctre.phoenix6.hardware.*;
import com.ctre.phoenix6.signals.*;
import com.ctre.phoenix6.swerve.*;
import com.ctre.phoenix6.swerve.SwerveModuleConstants.*;

import edu.wpi.first.math.Matrix;
import edu.wpi.first.math.numbers.N1;
import edu.wpi.first.math.numbers.N3;
import edu.wpi.first.units.measure.*;

import frc.robot.subsystems.CommandSwerveDrivetrain;

// Generated by the Tuner X Swerve Project Generator
// https://v6.docs.ctr-electronics.com/en/stable/docs/tuner/tuner-swerve/index.html
public final class TunerConstants {
        // Both sets of gains need to be tuned to your individual robot.

        // The steer motor uses any SwerveModule.SteerRequestType control request with
        // the
        // output type specified by SwerveModuleConstants.SteerMotorClosedLoopOutput
        private static final Slot0Configs steerGains = new Slot0Configs()
                        .withKP(100
                        ).withKI(0).withKD(0)
                        .withKS(0.077023).withKV(2.4786).withKA(0.077097)
                        .withStaticFeedforwardSign(StaticFeedforwardSignValue.UseClosedLoopSign);
        // When using closed-loop control, the drive motor uses the control
        // output type specified by SwerveModuleConstants.DriveMotorClosedLoopOutput
        private static final Slot0Configs driveGains = new Slot0Configs()
                        .withKP(0.16618).withKI(0).withKD(0)
                        .withKS(0.086163).withKV(0.11562);

        // The closed-loop output type to use for the steer motors;
        // This affects the PID/FF gains for the steer motors
        private static final ClosedLoopOutputType STEER_CLOSED_LOOP_OUTPUT = ClosedLoopOutputType.Voltage;
        // The closed-loop output type to use for the drive motors;
        // This affects the PID/FF gains for the drive motors
        private static final ClosedLoopOutputType DRIVE_CLOSED_LOOP_OUTPUT = ClosedLoopOutputType.Voltage;

        // The type of motor used for the drive motor
        private static final DriveMotorArrangement DRIVE_MOTOR_TYPE = DriveMotorArrangement.TalonFX_Integrated;
        // The type of motor used for the drive motor
        private static final SteerMotorArrangement STEER_MOTOR_TYPE = SteerMotorArrangement.TalonFX_Integrated;

        // The remote sensor feedback type to use for the steer motors;
        // When not Pro-licensed, Fused*/Sync* automatically fall back to Remote*
        private static final SteerFeedbackType STEER_FEEDBACK_TYPE = SteerFeedbackType.FusedCANcoder;

        // The stator current at which the wheels start to slip;
        // This needs to be tuned to your individual robot
        private static final Current SLIP_CURRENT = Amps.of(120.0);

        // Initial configs for the drive and steer motors and the azimuth encoder; these
        // cannot be null.
        // Some configs will be overwritten; check the `with*InitialConfigs()` API
        // documentation.
        private static final TalonFXConfiguration driveInitialConfigs = new TalonFXConfiguration();
        private static final TalonFXConfiguration steerInitialConfigs = new TalonFXConfiguration()
                        .withCurrentLimits(
                                        new CurrentLimitsConfigs()
                                                        // Swerve azimuth does not require much torque output, so we can
                                                        // set a
                                                        // relatively low
                                                        // stator current limit to help avoid brownouts without
                                                        // impacting performance.
                                                        .withStatorCurrentLimit(Amps.of(60))
                                                        .withStatorCurrentLimitEnable(true));
        private static final CANcoderConfiguration encoderInitialConfigs = new CANcoderConfiguration();
        // Configs for the Pigeon 2; leave this null to skip applying Pigeon 2 configs
        private static final Pigeon2Configuration pigeonConfigs = null;

        // CAN bus that the devices are located on;
        // All swerve devices must share the same CAN bus
        public static final CANBus CAN_BUS = new CANBus("", "./logs/example.hoot");

        // Theoretical free speed (m/s) at 12 V applied output;
        // This needs to be tuned to your individual robot
        public static final LinearVelocity SPEED_AT_12_VOLTS = MetersPerSecond.of(4.73);

        // Every 1 rotation of the azimuth results in COUPLE_RATIO drive motor turns;
        // This may need to be tuned to your individual robot
        private static final double COUPLE_RATIO = 3.5714285714285716;

        private static final double DRIVE_GEAR_RATIO = 6.746031746031747;
        private static final double STEER_GEAR_RATIO = 21.428571428571427;
        private static final Distance WHEEL_RADIUS = Inches.of(2);

        private static final boolean INVERT_LEFT_SIDE = false;
        private static final boolean INVERT_RIGHT_SIDE = true;

        private static final int PIGEON_ID = 1;

        // These are only used for simulation
        private static final MomentOfInertia STEER_INERTIA = KilogramSquareMeters.of(0.01);
        private static final MomentOfInertia DRIVE_INERTIA = KilogramSquareMeters.of(0.01);
        // Simulated voltage necessary to overcome friction
        private static final Voltage STEER_FRICTION_VOLTAGE = Volts.of(0.2);
        private static final Voltage DRIVE_FRICTION_VOLTAGE = Volts.of(0.2);

        public static final SwerveDrivetrainConstants DrivetrainConstants = new SwerveDrivetrainConstants()
                        .withCANBusName(CAN_BUS.getName())
                        .withPigeon2Id(PIGEON_ID)
                        .withPigeon2Configs(pigeonConfigs);

        private static final SwerveModuleConstantsFactory<TalonFXConfiguration, TalonFXConfiguration, CANcoderConfiguration> ConstantCreator = new SwerveModuleConstantsFactory<TalonFXConfiguration, TalonFXConfiguration, CANcoderConfiguration>()
                        .withDriveMotorGearRatio(DRIVE_GEAR_RATIO)
                        .withSteerMotorGearRatio(STEER_GEAR_RATIO)
                        .withCouplingGearRatio(COUPLE_RATIO)
                        .withWheelRadius(WHEEL_RADIUS)
                        .withSteerMotorGains(steerGains)
                        .withDriveMotorGains(driveGains)
                        .withSteerMotorClosedLoopOutput(STEER_CLOSED_LOOP_OUTPUT)
                        .withDriveMotorClosedLoopOutput(DRIVE_CLOSED_LOOP_OUTPUT)
                        .withSlipCurrent(SLIP_CURRENT)
                        .withSpeedAt12Volts(SPEED_AT_12_VOLTS)
                        .withDriveMotorType(DRIVE_MOTOR_TYPE)
                        .withSteerMotorType(STEER_MOTOR_TYPE)
                        .withFeedbackSource(STEER_FEEDBACK_TYPE)
                        .withDriveMotorInitialConfigs(driveInitialConfigs)
                        .withSteerMotorInitialConfigs(steerInitialConfigs)
                        .withEncoderInitialConfigs(encoderInitialConfigs)
                        .withSteerInertia(STEER_INERTIA)
                        .withDriveInertia(DRIVE_INERTIA)
                        .withSteerFrictionVoltage(STEER_FRICTION_VOLTAGE)
                        .withDriveFrictionVoltage(DRIVE_FRICTION_VOLTAGE);

        // Front Left
        private static final int FRONT_LEFT_DRIVE_MOTOR_ID = 23;
        private static final int FRONT_LEFT_STEER_MOTOR_ID = 27;
        private static final int FRONT_LEFT_ENCODER_ID = 32;
        private static final Angle FRONT_LEFT_ENCODER_OFFSET = Rotations.of(-0.387451171875);
        private static final boolean FRONT_LEFT_STEER_MOTOR_INVERTED = true;
        private static final boolean FRONT_LEFT_ENCODER_INVERTED = false;

        private static final Distance FRONT_LEFT_X_POS = Inches.of(11.875);
        private static final Distance FRONT_LEFT_Y_POS = Inches.of(11.875);

        // Front Right
        private static final int FRONT_RIGHT_DRIVE_MOTOR_ID = 26;
        private static final int FRONT_RIGHT_STEER_MOTOR_ID = 24;
        private static final int FRONT_RIGHT_ENCODER_ID = 31;
        private static final Angle FRONT_RIGHT_ENCODER_OFFSET = Rotations.of(0.022216796885);
        private static final boolean FRONT_RIGHT_STEER_MOTOR_INVERTED = true;
        private static final boolean FRONT_RIGHT_ENCODER_INVERTED = false;

        private static final Distance FRONT_RIGHT_X_POS = Inches.of(11.875);
        private static final Distance FRONT_RIGHT_Y_POS = Inches.of(-11.875);

        // Back Left
        private static final int BACK_LEFT_DRIVE_MOTOR_ID = 25;
        private static final int BACK_LEFT_STEER_MOTOR_ID = 20;
        private static final int BACK_LEFT_ENCODER_ID = 30;
        private static final Angle BACK_LEFT_ENCODER_OFFSET = Rotations.of(0.4951171875);
        private static final boolean BACK_LEFT_STEER_MOTOR_INVERTED = true;
        private static final boolean BACK_LEFT_ENCODER_INVERTED = false;

        private static final Distance BACK_LEFT_X_POS = Inches.of(-11.875);
        private static final Distance BACK_LEFT_Y_POS = Inches.of(11.875);

        // Back Right
        private static final int BACK_RIGHT_DRIVE_MOTOR_ID = 21;
        private static final int BACK_RIGHT_STEER_MOTOR_ID = 22;
        private static final int BACK_RIGHT_ENCODER_ID = 33;
        private static final Angle BACK_RIGHT_ENCODER_OFFSET = Rotations.of(-0.287841796885);
        private static final boolean BACK_RIGHT_STEER_MOTOR_INVERTED = true;
        private static final boolean BACK_RIGHT_ENCODER_INVERTED = false;

        private static final Distance BACK_RIGHT_X_POS = Inches.of(-11.875);
        private static final Distance BACK_RIGHT_Y_POS = Inches.of(-11.875);

        public static final SwerveModuleConstants<TalonFXConfiguration, TalonFXConfiguration, CANcoderConfiguration> FrontLeft = ConstantCreator
                        .createModuleConstants(
                                        FRONT_LEFT_STEER_MOTOR_ID, FRONT_LEFT_DRIVE_MOTOR_ID, FRONT_LEFT_ENCODER_ID,
                                        FRONT_LEFT_ENCODER_OFFSET,
                                        FRONT_LEFT_X_POS, FRONT_LEFT_Y_POS, INVERT_LEFT_SIDE,
                                        FRONT_LEFT_STEER_MOTOR_INVERTED,
                                        FRONT_LEFT_ENCODER_INVERTED);
        public static final SwerveModuleConstants<TalonFXConfiguration, TalonFXConfiguration, CANcoderConfiguration> FrontRight = ConstantCreator
                        .createModuleConstants(
                                        FRONT_RIGHT_STEER_MOTOR_ID, FRONT_RIGHT_DRIVE_MOTOR_ID, FRONT_RIGHT_ENCODER_ID,
                                        FRONT_RIGHT_ENCODER_OFFSET,
                                        FRONT_RIGHT_X_POS, FRONT_RIGHT_Y_POS, INVERT_RIGHT_SIDE,
                                        FRONT_RIGHT_STEER_MOTOR_INVERTED,
                                        FRONT_RIGHT_ENCODER_INVERTED);
        public static final SwerveModuleConstants<TalonFXConfiguration, TalonFXConfiguration, CANcoderConfiguration> BackLeft = ConstantCreator
                        .createModuleConstants(
                                        BACK_LEFT_STEER_MOTOR_ID, BACK_LEFT_DRIVE_MOTOR_ID, BACK_LEFT_ENCODER_ID,
                                        BACK_LEFT_ENCODER_OFFSET,
                                        BACK_LEFT_X_POS, BACK_LEFT_Y_POS, INVERT_LEFT_SIDE,
                                        BACK_LEFT_STEER_MOTOR_INVERTED,
                                        BACK_LEFT_ENCODER_INVERTED);
        public static final SwerveModuleConstants<TalonFXConfiguration, TalonFXConfiguration, CANcoderConfiguration> BackRight = ConstantCreator
                        .createModuleConstants(
                                        BACK_RIGHT_STEER_MOTOR_ID, BACK_RIGHT_DRIVE_MOTOR_ID, BACK_RIGHT_ENCODER_ID,
                                        BACK_RIGHT_ENCODER_OFFSET,
                                        BACK_RIGHT_X_POS, BACK_RIGHT_Y_POS, INVERT_RIGHT_SIDE,
                                        BACK_RIGHT_STEER_MOTOR_INVERTED,
                                        BACK_RIGHT_ENCODER_INVERTED);

        /**
         * Creates a CommandSwerveDrivetrain instance.
         * This should only be called once in your robot program,.
         */
        public static CommandSwerveDrivetrain createDrivetrain() {
                return new CommandSwerveDrivetrain(
                                DrivetrainConstants, FrontLeft, FrontRight, BackLeft, BackRight);
        }

        /**
         * Swerve Drive class utilizing CTR Electronics' Phoenix 6 API with the selected
         * device types.
         */
        public static class TunerSwerveDrivetrain extends SwerveDrivetrain<TalonFX, TalonFX, CANcoder> {
                /**
                 * Constructs a CTRE SwerveDrivetrain using the specified constants.
                 * <p>
                 * This constructs the underlying hardware devices, so users should not
                 * construct
                 * the devices themselves. If they need the devices, they can access them
                 * through
                 * getters in the classes.
                 *
                 * @param drivetrainConstants Drivetrain-wide constants for the swerve drive
                 * @param modules             Constants for each specific module
                 */
                public TunerSwerveDrivetrain(
                                SwerveDrivetrainConstants drivetrainConstants,
                                SwerveModuleConstants<?, ?, ?>... modules) {
                        super(
                                        TalonFX::new, TalonFX::new, CANcoder::new,
                                        drivetrainConstants, modules);
                }

                /**
                 * Constructs a CTRE SwerveDrivetrain using the specified constants.
                 * <p>
                 * This constructs the underlying hardware devices, so users should not
                 * construct
                 * the devices themselves. If they need the devices, they can access them
                 * through
                 * getters in the classes.
                 *
                 * @param drivetrainConstants     Drivetrain-wide constants for the swerve drive
                 * @param odometryUpdateFrequency The frequency to run the odometry loop. If
                 *                                unspecified or set to 0 Hz, this is 250 Hz on
                 *                                CAN FD, and 100 Hz on CAN 2.0.
                 * @param modules                 Constants for each specific module
                 */
                public TunerSwerveDrivetrain(
                                SwerveDrivetrainConstants drivetrainConstants,
                                double odometryUpdateFrequency,
                                SwerveModuleConstants<?, ?, ?>... modules) {
                        super(
                                        TalonFX::new, TalonFX::new, CANcoder::new,
                                        drivetrainConstants, odometryUpdateFrequency, modules);
                }

                /**
                 * Constructs a CTRE SwerveDrivetrain using the specified constants.
                 * <p>
                 * This constructs the underlying hardware devices, so users should not
                 * construct
                 * the devices themselves. If they need the devices, they can access them
                 * through
                 * getters in the classes.
                 *
                 * @param drivetrainConstants       Drivetrain-wide constants for the swerve
                 *                                  drive
                 * @param odometryUpdateFrequency   The frequency to run the odometry loop. If
                 *                                  unspecified or set to 0 Hz, this is 250 Hz
                 *                                  on
                 *                                  CAN FD, and 100 Hz on CAN 2.0.
                 * @param odometryStandardDeviation The standard deviation for odometry
                 *                                  calculation
                 *                                  in the form [x, y, theta]ᵀ, with units in
                 *                                  meters
                 *                                  and radians
                 * @param visionStandardDeviation   The standard deviation for vision
                 *                                  calculation
                 *                                  in the form [x, y, theta]ᵀ, with units in
                 *                                  meters
                 *                                  and radians
                 * @param modules                   Constants for each specific module
                 */
                public TunerSwerveDrivetrain(
                                SwerveDrivetrainConstants drivetrainConstants,
                                double odometryUpdateFrequency,
                                Matrix<N3, N1> odometryStandardDeviation,
                                Matrix<N3, N1> visionStandardDeviation,
                                SwerveModuleConstants<?, ?, ?>... modules) {
                        super(
                                        TalonFX::new, TalonFX::new, CANcoder::new,
                                        drivetrainConstants, odometryUpdateFrequency,
                                        odometryStandardDeviation, visionStandardDeviation, modules);
                }
        }
}
